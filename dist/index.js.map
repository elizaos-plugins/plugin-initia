{"version":3,"sources":["../src/actions/transfer.ts","../src/providers/wallet.ts","../src/index.ts"],"sourcesContent":["import {\n    Action,\n    ActionExample,\n    composeContext,\n    Content, elizaLogger, generateObjectDeprecated,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory, ModelClass,\n    State\n} from \"@elizaos/core\";\nimport { WalletProvider } from \"../providers/wallet\";\n\n\nexport interface TransferContent extends Content {\n    sender: string;\n    recipient: string;\n    amount: string;\n}\n\nfunction isTransferContent(_runtime: IAgentRuntime, content: unknown): content is TransferContent {\n    return (\n        typeof (content as TransferContent).sender === \"string\" && \n        typeof (content as TransferContent).recipient === \"string\" && \n        typeof (content as TransferContent).amount === \"string\"\n    );\n}\n\nconst transferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannt be determined.\n\nExample response:\n\\`\\`\\`json\n{\n    \"sender\": \"init18sj3x80fdjc6gzfvwl7lf8sxcvuvqjpvcmp6np\",\n    \"recipient\": \"init1kdwzpz3wzvpdj90gtga4fw5zm9tk4cyrgnjauu\",\n    \"amount\": \"1000uinit\",\n}\n\\`\\`\\`\n\n{{recentMessages}}\n\nGiven the recent messages, extract the following information about the requested token transfer:\n- Sender wallet address\n- Recipient wallet address\n- Amount to transfer\n\nRespond with a JSON markdown block containing only the extracted values.`;\n\nexport default {\n    name: \"SEND_TOKEN\",\n    similes: [\n        \"TRANSFER_TOKEN_ON_INITIA\",\n        \"TRANSFER_TOKENS_ON_INITIA\",\n        \"SEND_TOKEN_ON_INITIA\",\n        \"SEND_TOKENS_ON_INITIA\",\n        \"PAY_ON_INITIA\"\n    ],\n    description: \"\",\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        const privateKey = runtime.getSetting(\"INITIA_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        const transferContext = composeContext({\n            state: currentState,\n            template: transferTemplate,\n        });\n\n        const content = await generateObjectDeprecated({\n            runtime,\n            context: transferContext,\n            modelClass: ModelClass.LARGE,\n        });\n\n        if (!isTransferContent(runtime, content)) {\n            if (callback) {\n                callback({\n                    text: \"Unable to process transfer request. Invalid content provided.\",\n                    content: { error: \"Invalid transfer content\" }\n                });\n            }\n            return false;\n        }\n\n        try {\n            const initia = await import('@initia/initia.js');\n            const { MsgSend } = initia;\n\n            const walletProvider = new WalletProvider(runtime);\n            const msgSend = new MsgSend(\n                content.sender,\n                content.recipient,\n                content.amount,\n            );\n            const signedTx = await walletProvider.getWallet().createAndSignTx({\n                msgs: [msgSend],\n                memo: 'This transaction is made in ElizaOS',\n            });\n            const txResult = await walletProvider.sendTransaction(signedTx);\n            if (callback) {\n                callback({\n                    text: `Successfully transferred INITIA.\nTransaction Hash: ${txResult.txhash}\nSender: ${content.sender}\nRecipient: ${content.recipient}\nAmount: ${content.amount}`\n                });\n            }\n            return true;\n        } catch (e) {\n            elizaLogger.error(\"Failed to transfer INITIA:\", e.message);\n            if (callback) {\n                callback({\n                    text: `Failed to transfer INITIA: ${e.message}`\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Hey send 1 INIT to init18sj3x80fdjc6gzfvwl7lf8sxcvuvqjpvcmp6np.\"\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure! I am going to send 1 INIT to init18sj3x80fdjc6gzfvwl7lf8sxcvuvqjpvcmp6np.\"\n                }\n            }\n        ]\n    ] as ActionExample[][],\n} as Action;\n","import type { IAgentRuntime, Provider, Memory, State } from \"@elizaos/core\";\n\n// Add type imports for Initia.js\nimport type { Wallet, RESTClient, Tx } from '@initia/initia.js';\n\ninterface WalletProviderOptions {\n    chainId: string;\n    nodeUrl: string;\n}\n\nconst DEFAULT_INITIA_TESTNET_CONFIGS: WalletProviderOptions = {\n    chainId: 'initiation-2',\n    nodeUrl: 'https://rest.testnet.initia.xyz',\n}\n\nexport class WalletProvider {\n    private wallet: Wallet | null = null;\n    private restClient: RESTClient | null = null;\n    private runtime: IAgentRuntime;\n\n    async initialize(runtime: IAgentRuntime, options: WalletProviderOptions = DEFAULT_INITIA_TESTNET_CONFIGS) {\n        const privateKey = runtime.getSetting(\"INITIA_PRIVATE_KEY\");\n        if (!privateKey) throw new Error(\"INITIA_PRIVATE_KEY is not configured\");\n\n        const initia = await import('@initia/initia.js');\n        const { Wallet, RESTClient, RawKey } = initia;\n\n        this.runtime = runtime;\n        this.restClient = new RESTClient(\n            options.nodeUrl, {\n                chainId: options.chainId,\n                gasPrices: '0.15uinit',\n                gasAdjustment: '1.75'\n            });\n        this.wallet = new Wallet(this.restClient, RawKey.fromHex(privateKey));\n    }\n\n    constructor(runtime: IAgentRuntime, options: WalletProviderOptions = DEFAULT_INITIA_TESTNET_CONFIGS) {\n        this.runtime = runtime;\n        this.initialize(runtime, options);\n    }\n\n    getWallet() {\n        if (this.wallet == null) {\n            throw new Error(\"Initia wallet is not configured.\");\n        }\n        return this.wallet;\n    }\n\n    getAddress() {\n        if (this.wallet == null) {\n            throw new Error(\"Initia wallet is not configured.\");\n        }\n        return this.wallet.key.accAddress;\n    }\n\n    async getBalance() {\n        if (this.wallet == null) {\n            throw new Error(\"Initia wallet is not configured.\");\n        }\n        return this.wallet.rest.bank.balance(this.getAddress());\n    }\n\n    async sendTransaction(signedTx: Tx | string) {\n        return await this.restClient.tx.broadcast(signedTx);\n    }\n}\n\nexport const initiaWalletProvider: Provider = {\n    async get(runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<string | null> {\n        if (!runtime.getSetting(\"INITIA_PRIVATE_KEY\")) {\n            return null;\n        }\n\n        try {\n            const nodeUrl: string | null = runtime.getSetting(\"INITIA_NODE_URL\");\n            const chainId: string | null = runtime.getSetting(\"INITIA_CHAIN_ID\");\n            let walletProvider: WalletProvider;\n            if (nodeUrl === null || chainId === null) {\n                walletProvider = new WalletProvider(runtime);\n            } else {\n                walletProvider = new WalletProvider(runtime, { nodeUrl: nodeUrl, chainId: chainId } as WalletProviderOptions);\n            }\n\n            const address = walletProvider.getAddress();\n            const balance = await walletProvider.getBalance();\n            return `Initia Wallet Address: ${address}\\nBalance: ${balance} INIT`;\n        } catch (e) {\n            console.error(\"Error during configuring initia wallet provider\", e);\n            return null;\n        }\n    }\n}\n","import { Plugin } from \"@elizaos/core\";\nimport transfer from \"./actions/transfer\";\nimport { initiaWalletProvider } from \"./providers/wallet\";\n\nexport const initiaPlugin: Plugin = {\n    name: \"initiaPlugin\",\n    description: \"Initia Plugin for Eliza\",\n    actions: [\n        transfer,\n    ],\n    evaluators: [],\n    providers: [initiaWalletProvider],\n};\n"],"mappings":"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","names":[]}